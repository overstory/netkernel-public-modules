import org.netkernel.layer0.nkf.INKFAsyncRequestListener
import org.netkernel.layer0.nkf.INKFRequest
import org.netkernel.layer0.nkf.INKFRequestContext
import org.netkernel.layer0.nkf.INKFResponseReadOnly
import org.netkernel.layer0.nkf.NKFException
import org.netkernel.layer0.representation.IReadableBinaryStreamRepresentation

INKFRequestContext context = context

// Depends on "url" being passedin from outside

INKFRequest req = context.createRequest ("active:httpAsync")
req.addArgumentByValue ("method", "GET")
req.addArgument ("url", "arg:url")
req.addArgumentByValue ("callback", new MyListener(context))

//req.addArgumentByValue ("credentials", context.source ("res:/resources/config/http-credentials.xml"))
//req.addArgument ("golden-thread", "foo")
//req.addArgument ("golden-thread", "bar")

//req.addArgumentByValue ("listener", new MyListener())
req.setHeader (INKFRequest.HEADER_EXCLUDE_DEPENDENCIES, true);

context.issueAsyncRequest (req)

context.setNoResponse() //Let this thread carry on doing work for the kernel

// ---------------------------------

class MyListener implements INKFAsyncRequestListener
{
	def mContext
	
	def public MyListener(aContext)
	{	mContext=aContext	//Must supply original context - otherwise we can't get a response to the original request after setNoResponse()
	}
	
	@Override
	void receiveResponse (INKFResponseReadOnly response, INKFRequestContext context) throws Exception
	{
		context.createResponseFrom("")
		mContext.createResponseFrom (entityAsString (response.getRepresentation().getEntity())).setMimeType ("text/plain")
	}

	@Override
	void receiveException (NKFException exception, INKFRequest request, INKFRequestContext context) throws Exception
	{
		context.creatResponseFrom(exception)
		mContext.createResponseFrom (exception)
	}

	private String entityAsString (IReadableBinaryStreamRepresentation rep)
	{
		ByteArrayOutputStream baos = new ByteArrayOutputStream()

		rep.write (baos)

		new String (baos.toByteArray())
	}
}
